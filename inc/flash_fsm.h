/******************************************************************************
Finite State Machine
Project: can-flashing
Description: G

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.3
Generation date: 2023-06-22 12:56:27 +0200
Generated from: fsm.dot
The finite state machine has:
  8 states
  0 transition functions
******************************************************************************/

#ifndef FLASH_FSM_H
#define FLASH_FSM_H
#include <stdlib.h>

#include "inc/can.h"
#include "inc/flash_type.h"

// State data object
// By default set to void; override this typedef or load the proper
// header if you need
// typedef void state_data_t;
typedef struct{
  can_t can;
  FLASH_TYPE flash_device;
  char* binary_path;
}state_data_t;

// NOTHING SHALL BE CHANGED AFTER THIS LINE!

// List of states
typedef enum {
  STATE_START = 0,  
  STATE_SETUP_CAN,  
  STATE_ERROR,  
  STATE_FLASH_REQUEST,
  STATE_END,  
  STATE_FLASH_WAIT,  
  STATE_FLASHING,  
  STATE_SUCCESS,  
  NUM_STATES,
  NO_CHANGE
} state_t;

// State human-readable names
extern const char *state_names[];

// State function prototype
typedef state_t state_func_t(state_data_t *data);

// State functions

// Function to be executed in state start
// valid return states: STATE_SETUP_CAN
state_t do_start(state_data_t *data);

// Function to be executed in state setup_can
// valid return states: STATE_ERROR, STATE_FLASH_REQUEST
state_t do_setup_can(state_data_t *data);

// Function to be executed in state error
// valid return states: STATE_END
state_t do_error(state_data_t *data);

// Function to be executed in state flash_request
// valid return states: STATE_ERROR, STATE_FLASH_WAIT
state_t do_flash_request(state_data_t *data);

// Function to be executed in state end
// valid return states: NO_CHANGE
state_t do_end(state_data_t *data);

// Function to be executed in state flash_wait
// valid return states: NO_CHANGE, STATE_ERROR, STATE_FLASH_WAIT, STATE_FLASHING
state_t do_flash_wait(state_data_t *data);

// Function to be executed in state flashing
// valid return states: STATE_ERROR, STATE_SUCCESS
state_t do_flashing(state_data_t *data);

// Function to be executed in state success
// valid return states: STATE_END
state_t do_success(state_data_t *data);


// List of state functions
extern state_func_t *const state_table[NUM_STATES];


// No transition functions

// state manager
state_t run_state(state_t cur_state, state_data_t *data);

#endif
