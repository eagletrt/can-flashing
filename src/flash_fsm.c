/******************************************************************************
Finite State Machine
Project: can-flashing
Description: G

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.3
Generation date: 2023-06-22 12:56:27 +0200
Generated from: fsm.dot
The finite state machine has:
  8 states
  0 transition functions
******************************************************************************/

#include <syslog.h>
#include "flash_fsm.h"

// SEARCH FOR Your Code Here FOR CODE INSERTION POINTS!

// GLOBALS
// State human-readable names
const char *state_names[] = {"start", "setup_can", "error", "flash_request", "end", "flash_wait", "flashing", "success"};

// List of state functions
state_func_t *const state_table[NUM_STATES] = {
  do_start,         // in state start
  do_setup_can,     // in state setup_can
  do_error,         // in state error
  do_flash_request, // in state flash_request
  do_end,           // in state end
  do_flash_wait,    // in state flash_wait
  do_flashing,      // in state flashing
  do_success,       // in state success
};
// No transition functions

/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state start
// valid return states: STATE_SETUP_CAN
state_t do_start(state_data_t *data) {
  state_t next_state = STATE_SETUP_CAN;
  
  syslog(LOG_INFO, "[FSM] In state start");
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_SETUP_CAN:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from start to %s, remaining in this state", state_names[next_state]);
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state setup_can
// valid return states: STATE_ERROR, STATE_FLASH_REQUEST
state_t do_setup_can(state_data_t *data) {
  state_t next_state = STATE_ERROR;
  
  syslog(LOG_INFO, "[FSM] In state setup_can");
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_ERROR:
    case STATE_FLASH_REQUEST:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from setup_can to %s, remaining in this state", state_names[next_state]);
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state error
// valid return states: STATE_END
state_t do_error(state_data_t *data) {
  state_t next_state = STATE_END;
  
  syslog(LOG_INFO, "[FSM] In state error");
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_END:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from error to %s, remaining in this state", state_names[next_state]);
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state flash_request
// valid return states: STATE_ERROR, STATE_FLASH_WAIT
state_t do_flash_request(state_data_t *data) {
  state_t next_state = STATE_ERROR;
  
  syslog(LOG_INFO, "[FSM] In state flash_request");
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_ERROR:
    case STATE_FLASH_WAIT:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from flash_request to %s, remaining in this state", state_names[next_state]);
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state end
// valid return states: NO_CHANGE
state_t do_end(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  syslog(LOG_INFO, "[FSM] In state end");
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from end to %s, remaining in this state", state_names[next_state]);
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state flash_wait
// valid return states: NO_CHANGE, STATE_ERROR, STATE_FLASH_WAIT, STATE_FLASHING
state_t do_flash_wait(state_data_t *data) {
  state_t next_state = NO_CHANGE;
  
  syslog(LOG_INFO, "[FSM] In state flash_wait");
  /* Your Code Here */
  
  switch (next_state) {
    case NO_CHANGE:
    case STATE_ERROR:
    case STATE_FLASH_WAIT:
    case STATE_FLASHING:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from flash_wait to %s, remaining in this state", state_names[next_state]);
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state flashing
// valid return states: STATE_ERROR, STATE_SUCCESS
state_t do_flashing(state_data_t *data) {
  state_t next_state = STATE_ERROR;
  
  syslog(LOG_INFO, "[FSM] In state flashing");
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_ERROR:
    case STATE_SUCCESS:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from flashing to %s, remaining in this state", state_names[next_state]);
      next_state = NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state success
// valid return states: STATE_END
state_t do_success(state_data_t *data) {
  state_t next_state = STATE_END;
  
  syslog(LOG_INFO, "[FSM] In state success");
  /* Your Code Here */
  
  switch (next_state) {
    case STATE_END:
      break;
    default:
      syslog(LOG_WARNING, "[FSM] Cannot pass from success to %s, remaining in this state", state_names[next_state]);
      next_state = NO_CHANGE;
  }
  
  return next_state;
}



/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

state_t run_state(state_t cur_state, state_data_t *data) {
  state_t new_state = state_table[cur_state](data);
  if (new_state == NO_CHANGE) new_state = cur_state;
  return new_state == NO_CHANGE ? cur_state : new_state;
};

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
  state_t cur_state = STATE_START;
  openlog("SM", LOG_PID | LOG_PERROR, LOG_USER);
  syslog(LOG_INFO, "Starting SM");
  do {
    cur_state = run_state(cur_state, NULL);
    sleep(1);
  } while (cur_state != STATE_END);
  run_state(cur_state, NULL);
  return 0;
}
#endif
